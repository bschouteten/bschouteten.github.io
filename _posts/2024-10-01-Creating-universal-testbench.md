---
title: Creating a universal test bench
date: 2024-01-10
author: bschouteten
---

# Creating a universal test bench

Welcome to the second part of this blog. In the previous part we installed verilator and compiled our system verilog code in C++. Next to this we created a top level testbench and made our clock tick 20 times, which in the end was also visible in GTK wave. 

For this part we will continue with our previous design, but expand it in such way that we can re-use it as much as possible between multiple designs. For this we will use C++ inheritance, so creating a base class for a general testbench and then use a design specific class which derives the base class. Next to this we will also add some general usefull features to make our life easier. First some configurable logging which we can use to printout information into our terminal. Secondly some program options so that we can configure/enable certain parts of the code, think like enabling/disabling the trace.

From a software design perspective it will look like the image below.

![Global](/images/blog2/UMLGlobalDesign.png)

# Adding logging into our program

Let’s first start with the logger, since this is the easiest to implement and we can immediately show some runtime information in the terminal of this program. Since this logger shall be used from all different files and possibly even from multiple threads it’s important to make sure that it is safe to use and only has a single implementation. For this a singleton class is used, so there are never multiple instances off the logger. Also everyone can get/create a log instance, which at that point will always be the same instance.

The logger has to be configurable in such a way that it reacts accordingly to priorities, writes depending on what the users wants, to a given file or into the terminal. It should also be easy to use and very easy to read and understand when used throughout the system. The goal here is not to explain the functionality of the logger, just the idea on how the logger is designed and how it is used throughout the system. There are two important things which must be done to use the logger, first it has to be initialized with the corresponding log priority and the file (or no file when terminal is used). Secondly it has to be closed at the end of program, so the open file is closed correctly and can be read. Since it is a singleton class, this is a little bit different from the normal usage. So initializing and closing will look the following: 

``` C++
cLog::getInstance()->init(<log priority>, <filename>);
cLog::getInstance()->close();
```

Writing something to the logger is made very simple and readable. For this a few defines are created to make it very easy to read and information can be appended to those defines.

``` C++
#define DEBUG   RoaLogic::common::cLog::getInstance()->log(RoaLogic::common::eLogPriority::Debug)
#define LOG     RoaLogic::common::cLog::getInstance()->log(RoaLogic::common::eLogPriority::Log)
#define INFO    RoaLogic::common::cLog::getInstance()->log(RoaLogic::common::eLogPriority::Info)
#define WARNING RoaLogic::common::cLog::getInstance()->log(RoaLogic::common::eLogPriority::Warning)
#define ERROR   RoaLogic::common::cLog::getInstance()->log(RoaLogic::common::eLogPriority::Error)
#define FATAL   RoaLogic::common::cLog::getInstance()->log(RoaLogic::common::eLogPriority::Fatal)
```
 
Writing something to the log will be the same as writing to std::cout, also integers or other values can be given to the logger and be shown. See small examples below, the text is written with the priority level info.

``` C++
INFO << "Initialized logger \n";
INFO << "Loopcounter: " << i << "\n";
```
 
The logger implementation itself is placed in the log.hpp and log.cpp files. Small example build on top of our previous main program is below. This just prints some info debug messages to the terminal and shows the loop counter.

```C++
#include <log.hpp>
//For Verilator methods
#include <verilated.h>
#include <verilated_vcd_c.h>
//Include specific model header, generated by Verilator
#include "Vapb_uart16550.h"

using namespace RoaLogic::common;

int main(int argc, char** argv) 
{
    std::unique_ptr<VerilatedContext> contextp(new VerilatedContext);
    VerilatedContext* _context = contextp.get();  // Verilator Context
    Vapb_uart16550* _core = new Vapb_uart16550;   // Verilator Model to test

    // Initialize the logger with priority info and no filename 
    // so it writes to the terminal
    cLog::getInstance()->init(eLogPriority::Info, "");
    INFO << "Initialized logger \n";

    // Parse the given parameters into this application
    contextp->commandArgs(argc, argv);  
    Verilated::traceEverOn(true);
    VerilatedVcdC* _trace = new VerilatedVcdC;
    _core->trace(_trace, 99);
    _trace->open("waveform.vcd");

    INFO << "Starting loop \n";
    // loop 20 times
    for (size_t i = 0; i < 20; i++)   
    { 
        _core->PCLK ^= 1;
        _core->eval();
        _trace->dump(i);
        INFO << "Loopcounter: " << i << "\n";
    }

    INFO << "Loop ended closing \n";
    // finalize the design
    _core->final();
    _trace->close();
    delete _core;

    // Close the log
    cLog::getInstance()->close();

    return 0;
}

```
 
Running this code will show the following in the terminal:
 
```
--- Running tb_apb_uart16550
[INFO] Initialized logger
[INFO] Starting loop
[INFO] Loopcounter: 0
[INFO] Loopcounter: 1
[INFO] Loopcounter: 2
[INFO] Loopcounter: 3
[INFO] Loopcounter: 4
[INFO] Loopcounter: 5
[INFO] Loopcounter: 6
[INFO] Loopcounter: 7
[INFO] Loopcounter: 8
[INFO] Loopcounter: 9
[INFO] Loopcounter: 10
[INFO] Loopcounter: 11
[INFO] Loopcounter: 12
[INFO] Loopcounter: 13
[INFO] Loopcounter: 14
[INFO] Loopcounter: 15
[INFO] Loopcounter: 16
[INFO] Loopcounter: 17
[INFO] Loopcounter: 18
[INFO] Loopcounter: 19
```


# Program options

Now we can see what out program is doing, it’s also helpful to add some program options so that we can enable parts of the program without having to comment and uncomment every time we want to run. For this we also use a standard module, where many different ones can be found online.  It’s not within scope to fully explain how the program options work, let’s just check how to use it and what’s helpful to implement. 
First we include the corresponding headers,

``` C++
#include <noValueOption.hpp>
#include <valueOption.hpp>
```

The no value option is used to create program options with no value, for example to enable something or show the help information. Where the value option is used to parse a certain value with a program option. Let’s go and try some things out.
First we add the lines below, here we create the option parser itself and the corresponding options. First argument is the short argument, second argument is the long argument, followed by the explanation, which will be shown in the help. The cNoValueOption has a default initializer which is set to false, meaning it will by default be inactive and when parsed into the program it will become active.

``` C++
cProgramOptions programOptions;
cNoValueOption helpOption("h", "help", "Show this help and exit", false);
cValueOption<bool> boolOption("b", "bool", "Test for boolean, defaults to false. Option could be '1', true, True or TRUE");

programOptions.add(&helpOption);
programOptions.add(&boolOption);

programOptions.parse(argc, argv);
```

After creating the options, they are added to the program options we created. Finally the parse is called with the options given to the program. It will traverse all the options given and will set the given options if they are available. This can be checked as seen below, if the help option isSet(), we call the print known options which will show all options in the terminal.

``` C++
if(helpOption.isSet())
{
    programOptions.printKnownOptions();
    return 0;
}
```

Extracting a value from the given program options can be done in the following way. Do note that this is non functional code, just as demonstration on how it could be done.
```C++
if(boolOption.isSet())
{
    bool givenValue = boolOption.value();

    if(givenValue)
    {
        return 0;
    }
}
```

This part was mainly to describe the program options, nothing major has changed in our program. Let’s continue now by making a more general design, where we incorporate the logging and program options.

# Creating a general testbench

Setting up and running a testbench always happens in the same way, so it's easy to have a general class and functions for this. Every different testbench can then easily be derived from the base class, having the basics already implemented and only the design specifics need attention.  

So what is general and what do we add in the base class. As first the creating of the Verilated models and the creation of the verilated model. Next to this the control of the simulation core and trace support. From a SW perspective it will look like the following UML diagram.

![UML testbench](/images/blog2/UMLDiagramTestbenchBase.png)

From our UML the following header file will pop up.

``` C++
template <class VM> class cTestBench
{
    private:
        VerilatedContext*  _context;    //!< Verilator Context
        VerilatedVcdC*     _trace;      //!< Verilator Trace instance 
        bool               _traceActive; //!< Boolean to store if the trace is active or not
        bool               _finished;   //!< Bool to check if the testbench has finished

    protected:
        VM*                _core;     //!< Verilator Model to test

        virtual void tick(void) const;

        virtual void finish(void);
        virtual bool finished(void) const;

    public:

        cTestBench(VerilatedContext* context, bool traceActive);
        virtual ~cTestBench(void);

        void opentrace(const char *fileName);
        void closeTrace(void);
};
```

As first the class is a template class, so that it can handle all the different verilated context's. A pointer to this context is then stored into the private variables, next to this also the trace instance is stored within this class. Any derived class should not worry about any of those two, since it will be handled internally within this class. Also in the private variables are two booleans to store the state if the trace is activated and if the simulation is finished. The trace activation is passed by the constructor where the _finished flag can be used to stop the simulation. The _core is protected, since it could be that the derived class needs access to it, due that the _core has the knowledge of the pins.

## Constructor and destructor

The constructor and destructor are used to create the class but also to destroy it appropriately. It will start the trace according to the passed parameter, where the destructor will gracefully shutdown the trace and cleanup the core of the simulation context. As we look closely this is the same code from our previous main routine, where the constructor replaces the initial instantation of the verilated context. The destructor replaces the last few lines of our previous main routine.

``` C++
template <class VM>
cTestBench<VM>::cTestBench(VerilatedContext* context, bool traceActive) :
    _context(context),
    _finished(false),
    _traceActive(traceActive)
{
    if(traceActive)
    {
        Verilated::traceEverOn(true);
    }

    _core = new VM; // Create a new verilator model
}

template <class VM>
cTestBench<VM>::~cTestBench(void)
{
    // Always close the trace, even if it is not activated
    closeTrace();

    //Finalize the core and Cleanup
    _core->final();
    delete _core;
}
```

## Tracing

Tracing can be initially configured by the constructor, where it enables the global tracing within the verilated context. However to function properly a trace has to be opened first, which is done by the openTrace function. A file name and location is passed into this and the trace is then stored in this file. This is also the same as in our previous main routine, just placed within the base class of a universal testbench. The close trace function will close the trace, as done in our main routine. But next to this we now also flush it, to make sure everything is written to it. 

``` C++
template <class VM>
void cTestBench<VM>::opentrace(const char *fileName) 
{
    if(_traceActive)
    {
        if (!_trace) 
        {
            _trace = new VerilatedVcdC;
            _core->trace(_trace, 99);
            _trace->open(fileName);
        }
    }
    else
    {
        ERROR << "Trace is not active, no need to open";
    }
}

template <class VM>
void cTestBench<VM>::closeTrace(void) 
{
    if (_trace) 
    {
        _trace->flush();
        _trace->close();
        _trace = NULL;
    }
}

```

## Controlling the testbench

Now the last part for our generic testbench, we need to tick, evaluate and check if the testbench has finished. Let's first start with explaining the finish and finished function. With the finish function, the _finished flag is set to true, this doesn't stop the simulation, however it gives a general function to let the testbench know it has to stop. Where the finished function returns a boolean, the value of this boolean is determined by the _finished flag and next to this by the _context-gotFinish() function. This function checks if a system verilog ``` $finish() ``` statement is triggered. Any derived class should use this finised function to see if the simulation has ended. 

``` C++
template <class VM>
void cTestBench<VM>::finish(void)
{
    _finished = true;
}

template <class VM>
bool cTestBench<VM>::finished(void) const
{
    return (_context->gotFinish() | _finished);
}
```

The tick function is to evaluate the design and if configured dump the related information into the trace. For now it doesn't do much more, since there is no more logic needed. However later on we will extend it to also advance the clocks in the design.

``` C++
    template <class VM>
    void cTestBench<VM>::tick(int tickCount) const
    {
    #ifdef DBG_TESTBENCH_H
        DEBUG << "TESTBENCH_H - tick()" << std::endl;
    #endif

        //eval logic
        _core->eval();

        //dump trace
        if (_traceActive && _trace)
        {
            _trace->dump( tickCount );
        } 
    }
```

# UART16550 testbench class

We now have a general testbench class, however we still need to have a specific class for our UART16550 module. So let's construct this module and then proceed to run the simulation. This module inherits the general testbench and has one function run, which will run the testbench for the given number of cycles. For now this is sufficient to see if our general testbench class is doing what we expect.

The constructor and destructor are very generic and don't have much specific. Where the run function is mainly the same as our for loop in the previous design, except that now the tick function of the general testbench is called instead of directly evaluating and dumping.

``` C++
class cAPBUart16550TestBench : public RoaLogic::testbench::cTestBench<Vapb_uart16550>
{
    public:

        cAPBUart16550TestBench(VerilatedContext* context, bool traceActive);
        ~cAPBUart16550TestBench();

        int run(int numCycles);
};

cAPBUart16550TestBench::cAPBUart16550TestBench(VerilatedContext* context, bool traceActive) : 
    cTestBench<Vapb_uart16550>(context, traceActive)
{
}

cAPBUart16550TestBench::~cAPBUart16550TestBench()
{
}

int cAPBUart16550TestBench::run(int numCycles)
{
    for (size_t i = 0; i < numCycles; i++)   
    {
        _core->PCLK ^= 1;
        tick(i);

        #ifdef DEBUG_TESTBENCH
        DEBUG << "Loopcounter: " << i << "\n";
        #endif
    }

    return 0;
}

```

# New main file

Since there are quite some updated, our main file also has to be updated to respect the changes and additions we have made. See below for the complete main.c file.

First the needed include files are added, following this the right namespace is set. Also the program options are set outside of the main function and two additional functions are added. This is done to keep the main function as simple as possible and not overflow it with information which can be read in their corresponding functions if needed. 

setupProgramOptions function will add the corresponding program options, parse the given options and check if the help is requested. If help is requested it will printout the help and then shutdown, else it will continue the program execution. This must be called directly in the beginning of the main routine.

Following this part, we will setup the logger so that it's possible to log information from the beginning of our program. Logger is configured according to the given program options, which will set the level and the file or terminal.

Now it's time to create our new testbench class, which is partly the same as in our previous main file. The verilatedContext is created as a unique pointer, which first checks if there are any options for verilator passed into the program. When this is done, it's now time to instantiate a UART16550 testbench class and call the corresponding constructor. If the trace is needed, it will be opened. After this the testbench is run for 20 cycles and then everything is deleted and closed off, finishing our program. 

Only changes from our previous main routine now are the adding of the program options, the logger and the call to the testbench. From a simulation perspective it will still do the same and run for 20 cycles.

``` C++
#include "tb_apb_uart16550.hpp"

#include <noValueOption.hpp>
#include <valueOption.hpp>

using namespace RoaLogic;
using namespace common;
using namespace testbench;

cProgramOptions programOptions;

cNoValueOption helpOption("h", "help", "Show this help and exit", false);
cNoValueOption traceOption("t", "trace", "Trace option, is given the trace will be enabled", false);
cValueOption<std::string> logOption("l", "log", "Log file path, when not specified log is written to terminal");    
cValueOption<uint8_t> logPriorityOption("p", "priority", "Log priority. Debug = 0, Log = 1, Info = 2, Warning = 3, Error = 4, Fatal = 5");

int setupProgramOptions(int argc, char** argv);
void setupLogger(void);

int main(int argc, char** argv) 
{
    bool withTrace = false;
    // First setup the program options and followed by this setup the logger module
    if(setupProgramOptions(argc, argv))
    {
        return 0;
    }

    setupLogger();

    withTrace = traceOption.isSet();

    // Now let's setup our testbench
    std::unique_ptr<VerilatedContext> contextp(new VerilatedContext);
    contextp->commandArgs(argc, argv); // Parse the eventual option for verilator
    //Create model for DUT
    cAPBUart16550TestBench* testbench = new cAPBUart16550TestBench(contextp.get(), withTrace);

    // Open the trace if this is enabled
    if(withTrace)
    {
        testbench->opentrace("waveform.vcd");
    }

    // Run the testbench for 20 cycles
    testbench->run(20);

    // finalize the design
    delete testbench;

    // Close the log
    cLog::getInstance()->close();

    return 0;
}

int setupProgramOptions(int argc, char** argv)
{
    programOptions.add(&helpOption);
    programOptions.add(&traceOption);
    programOptions.add(&logOption);
    programOptions.add(&logPriorityOption);

    programOptions.parse(argc, argv);

    if(helpOption.isSet())
    {
        programOptions.printKnownOptions();
        return 1;
    }

    return 0;
}

void setupLogger(void)
{
    uint8_t logPriority = 0;

    if (logPriorityOption.isSet())
    {
        logPriority = logPriorityOption.value();
    }
    else
    {
        logPriority = 2;
    }    

    if(logOption.isSet())
    {
        cLog::getInstance()->init(logPriority, logOption.value());
    }
    else
    {
        cLog::getInstance()->init(logPriority, "");
    }

    INFO << "Started log with priority: " << logPriority << "\n";
}


```

Running the main routine with the log level set to ```DEBUG``` and compiled with ```DEBUG_TESTBENCH``` enabled will show the following output in the terminal:

``` 
--- Building tb_apb_uart16550
--- Running tb_apb_uart16550
[INFO] Started log with priority:
[DEBUG] Loopcounter: 0
[DEBUG] Loopcounter: 1
[DEBUG] Loopcounter: 2
[DEBUG] Loopcounter: 3
[DEBUG] Loopcounter: 4
[DEBUG] Loopcounter: 5
[DEBUG] Loopcounter: 6
[DEBUG] Loopcounter: 7
[DEBUG] Loopcounter: 8
[DEBUG] Loopcounter: 9
[DEBUG] Loopcounter: 10
[DEBUG] Loopcounter: 11
[DEBUG] Loopcounter: 12
[DEBUG] Loopcounter: 13
[DEBUG] Loopcounter: 14
[DEBUG] Loopcounter: 15
[DEBUG] Loopcounter: 16
[DEBUG] Loopcounter: 17
[DEBUG] Loopcounter: 18
[DEBUG] Loopcounter: 19

```

We now are at the same point as our previous blog, except that we have a universal testbench and can re-use this. So if we have a different system verilog design, it would be very easy to adjust the current files to support it fully. In the next blog we will go into generating a universal clocking mechanism, where we add support for multi clock designs and make sure those alternate in the desired frequency. Next to this we will also look into how we sync and run everything on a event base.